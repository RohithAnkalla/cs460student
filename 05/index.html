<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>CS460 A5</title>
    <style>
      html, body {
        margin: 0; padding: 0; height: 100%;
        overflow: hidden; background: #0a0a0a;
      }
      canvas { display: block; }
    </style>

    <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>

    <script async src="https://unpkg.com/es-module-shims@1.9.0/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { AnaglyphEffect } from "three/addons/effects/AnaglyphEffect.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { VertexNormalsHelper } from "three/addons/helpers/VertexNormalsHelper.js";
      import { Pane } from "https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js";

      let scene, camera, renderer, controls, effect;
      let stats;
      let dirLight, ambientLight;

      const STATE = { polyGroup: null, blenderGroup: null };

      const POLY_TARGET_SIZE   = 4.0;
      const EDITED_TARGET_SIZE = 40.0;

      window.SCENE = {
        anaglyph: false,

        poly: null,
        blender: null,
        blender_helper: null,

        rotate_poly: false,
        rotate_blender: false,

        blender_old_material: null,

        do_rotate_poly() {
          window.SCENE.rotate_poly = !window.SCENE.rotate_poly;
        },
        do_rotate_blender() {
          window.SCENE.rotate_blender = !window.SCENE.rotate_blender;
        },
        change_material() {
          const s = window.SCENE;
          if (!s.blender) return;

          if (!s.blender_old_material) {
            s.blender_old_material = s.blender.material.clone();
            s.blender.material = new THREE.MeshNormalMaterial();
          } else {
            s.blender.material = s.blender_old_material.clone();
            s.blender_old_material = null;
          }
        }
      };

      let pane, sceneui, polyui, blenderui;

      window.onload = () => {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 10000);
        camera.position.set(0, 2.5, 10);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.setSize(innerWidth, innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        effect = new AnaglyphEffect(renderer);
        effect.setSize(innerWidth, innerHeight);

        stats = new Stats();
        document.body.appendChild(stats.domElement);

        dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        ambientLight = new THREE.AmbientLight(0xffffff, 0.25);
        scene.add(ambientLight);

        const loader = new GLTFLoader();
        function prepAsCenteredGroup(root, targetMaxAxis = 4) {
          let obj = root;
          if (root.children && root.children.length === 1) obj = root.children[0];

          obj.rotation.set(0, 0, 0);
          obj.quaternion.set(0, 0, 0, 1);

          obj.updateMatrixWorld(true);
          const box = new THREE.Box3().setFromObject(obj);
          const size = new THREE.Vector3();
          const center = new THREE.Vector3();
          box.getSize(size);
          box.getCenter(center);

          obj.position.sub(center);

          const maxAxis = Math.max(size.x, size.y, size.z);
          const s = (maxAxis > 0) ? (targetMaxAxis / maxAxis) : 1;
          obj.scale.setScalar(s);

          const group = new THREE.Group();
          group.add(obj);

          group.updateMatrixWorld(true);
          return { group, object: obj };
        }

        pane = new Pane();
        sceneui = pane.addFolder({ title: "Scene", expanded: true });

        sceneui.addBinding(window.SCENE, "anaglyph", { label: "Anaglyph" });

        sceneui.addBinding(dirLight.position, "x", { min: -100, max: 100, label: "Light X" });
        sceneui.addBinding(dirLight.position, "y", { min: -100, max: 100, label: "Light Y" });
        sceneui.addBinding(dirLight.position, "z", { min: -100, max: 100, label: "Light Z" });

        sceneui.addBinding(dirLight, "intensity", { min: 0, max: 5, label: "Light Intensity" });

        const ambientHelper = {
          color: { r: 255, g: 255, b: 255 }
        };
        sceneui.addBinding(ambientHelper, "color", { view: "color", label: "Ambient Color" })
          .on("change", (e) => {
            const c = e.value;
            ambientLight.color.setRGB(c.r / 255, c.g / 255, c.b / 255);
          });

        loader.load(
          "poly.glb",
          (gltf) => {
            const { group, object } = prepAsCenteredGroup(gltf.scene, POLY_TARGET_SIZE);
            group.position.set(3.0, 0, 0);
            scene.add(group);
            STATE.polyGroup = group;
            window.SCENE.poly = object;

            if (!polyui) {
              polyui = pane.addFolder({ title: "PolyCam Mesh", expanded: true });
            }

            if (window.SCENE.poly.material) {
              polyui.addBinding(window.SCENE.poly.material, "wireframe", { label: "Wireframe" });
            }

            polyui
              .addButton({ title: "Rotate!" })
              .on("click", () => {
                window.SCENE.do_rotate_poly();
              });
          },
          undefined,
          (err) => console.error("Failed to load poly.glb:", err)
        );

        loader.load(
          "edited.glb",
          (gltf) => {
            const { group, object } = prepAsCenteredGroup(gltf.scene, EDITED_TARGET_SIZE);
            group.position.set(-3.0, 0, 0);
            scene.add(group);
            STATE.blenderGroup = group;
            window.SCENE.blender = object;

            const helper = new VertexNormalsHelper(object, 0.1, "blue");
            helper.visible = false;
            scene.add(helper);
            window.SCENE.blender_helper = helper;

            if (!blenderui) {
              blenderui = pane.addFolder({ title: "Blender Mesh", expanded: true });
            }

            blenderui.addBinding(helper, "visible", { label: "Show normals!" });

            blenderui
              .addButton({ title: "Rotate!" })
              .on("click", () => {
                window.SCENE.do_rotate_blender();
              });

            blenderui
              .addButton({ title: "Change Material!" })
              .on("click", () => {
                window.SCENE.change_material();
              });
          },
          undefined,
          (err) => console.error("Failed to load edited.glb:", err)
        );

        addEventListener("resize", onResize);
        animate();
      };

      function onResize() {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
        effect.setSize(innerWidth, innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        controls.update();

        if (window.SCENE.poly) {
          const q = new THREE.Quaternion();
          if (window.SCENE.rotate_poly) {
            q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
          } else {
            q.identity();
          }
          window.SCENE.poly.quaternion.slerp(q, 0.05);
        }

        if (window.SCENE.blender) {
          const q2 = new THREE.Quaternion();
          if (window.SCENE.rotate_blender) {
            q2.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
          } else {
            q2.identity();
          }
          window.SCENE.blender.quaternion.slerp(q2, 0.05);

          if (window.SCENE.blender_helper) {
            window.SCENE.blender_helper.update();
          }
        }

        if (window.SCENE.anaglyph) {
          effect.render(scene, camera);
        } else {
          renderer.render(scene, camera);
        }

        stats.update();
      }
    </script>
  </body>
</html>